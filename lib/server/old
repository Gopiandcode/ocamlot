    | CreateNote { id; author; to_; cc;
                   sensitive; direct_message;
                   source; summary; content;
                   published; tags; data; } ->
      let res =
        Fun.flip Caqti_lwt.Pool.use pool @@ fun db ->
        let+ author =
          let+ author = Resolver.resolve_remote_user_by_url (Uri.of_string author) db
                        |> sanitize in
          Database.Actor.of_remote (Database.RemoteUser.self author) db  |> sanitize
        in
        let+ is_public, to_ =
          Lwt_list.fold_left_s (fun acc vl ->
            let+ (is_public, tgts) = return acc in
            match vl with
            | "https://www.w3.org/ns/activitystreams#Public" -> Lwt.return_ok (true, tgts)
            | target ->
              let+ target =
                let user_re = Re.compile (Configuration.Regex.local_user_id_format config) in
                match Re.exec_opt user_re target with
                | None ->
                  let+ remote_user = Resolver.resolve_remote_user_by_url (Uri.of_string target) db in
                  Database.Actor.of_remote (Database.RemoteUser.self remote_user) db
                | Some matches ->
                  let username = Re.Group.get matches 1 in
                  let+ local_user = Database.LocalUser.lookup_user_exn ~username db in
                  Database.Actor.of_local (Database.LocalUser.self local_user) db in
              Lwt.return_ok (is_public, target :: tgts)
          ) (Ok (not sensitive && not direct_message, [])) to_
          |> sanitize in
        let+ cc =
          Lwt_list.fold_left_s (fun tgts target ->
            let+ tgts = Lwt.return tgts in
            if String.suffix ~suf:"followers" target
            then Lwt.return_ok tgts
            else let+ target =
                   let user_re = Re.compile (Configuration.Regex.local_user_id_format config) in
                   match Re.exec_opt user_re target with
                   | None ->
                     let+ remote_user = Resolver.resolve_remote_user_by_url (Uri.of_string target) db in
                     Database.Actor.of_remote (Database.RemoteUser.self remote_user) db
                   | Some matches ->
                     let username = Re.Group.get matches 1 in
                     let+ local_user = Database.LocalUser.lookup_user_exn ~username db in
                     Database.Actor.of_local (Database.LocalUser.self local_user) db in
              Lwt.return_ok (target :: tgts)
          ) (Ok []) cc
          |> sanitize in
    
        let+ mentions, tags =
          Lwt_list.fold_left_s (fun acc vl ->
            let+ (mentions, tags) = return acc in
            match vl with
            | `Value Activitypub.Types.{ ty=`Hashtag; href; name } ->
              let+ tag = 
                let+ tag = Database.Tag.create name db in
                Lwt.return_ok (Database.Tag.self tag, Some href) in
              Lwt.return_ok (mentions,tag :: tags)
            | `Value Activitypub.Types.{ ty=`Mention; href; name=_ } ->
              let+ target =
                let user_re = Re.compile (Configuration.Regex.local_user_id_format config) in
                match Re.exec_opt user_re href with
                | None ->
                  let+ remote_user = Resolver.resolve_remote_user_by_url (Uri.of_string href) db in
                  Database.Actor.of_remote (Database.RemoteUser.self remote_user) db
                | Some matches ->
                  let username = Re.Group.get matches 1 in
                  let+ local_user = Database.LocalUser.lookup_user_exn ~username db in
                  Database.Actor.of_local (Database.LocalUser.self local_user) db in
              Lwt.return_ok (target :: mentions,tags)
            |  _ -> Lwt.return_ok (mentions,tags)
          ) (Ok ([],[])) tags
          |> sanitize in
        let published = Option.value ~default:(Ptime_clock.now ()) published
                        |> Ptime.to_float_s |> CalendarLib.Calendar.from_unixfloat in
        let post_source = Option.value ~default:content source in
        let+ post = 
          Database.Post.create_post
            ?summary ~url:id  ~published ~author ~is_public ~post_source
            ~raw_data:(Yojson.Safe.to_string data) db |> sanitize in
        let+ () = Database.Post.add_post_tos (Database.Post.self post) to_ db |> sanitize in
        let+ () = Database.Post.add_post_ccs (Database.Post.self post) cc db |> sanitize in
        let+ () = Database.Post.add_post_tags (Database.Post.self post) tags db |> sanitize in
        let+ () = Database.Post.add_post_mentions (Database.Post.self post) mentions db |> sanitize in
    
        Lwt_result.return ()
      in
      Lwt.bind res @@ fun res ->
      begin match res with
      | Ok () -> worker pool config
      | Error e ->
        let e = match e with
          | #Caqti_error.t as e -> Caqti_error.show e
          | `Msg e -> e in
        Dream.error (fun log -> log "error in worker: %s" e);
        worker pool config
      end        
    | AcceptRemoteFollow {follow; author; target} ->
      let res =
        Fun.flip Caqti_lwt.Pool.use pool @@ fun db ->
        Resolver.accept_remote_follow config follow author target db |> sanitize in
      Lwt.bind res @@ fun res ->
      begin match res with
      | Ok () -> worker pool config
      | Error e ->
        let e = match e with
          | #Caqti_error.t as e -> Caqti_error.show e
          | `Msg e -> e in
        Dream.error (fun log -> log "error in worker: %s" e);
        worker pool config
      end
    | RecordAcceptLocalFollow {follow; author; target} ->
      let res =
        Fun.flip Caqti_lwt.Pool.use pool @@ fun db ->
        Resolver.accept_local_follow config follow ~author ~target db |> sanitize in
      Lwt.bind res @@ fun res ->
      begin match res with
      | Ok () -> worker pool config
      | Error e ->
        let e = match e with
          | #Caqti_error.t as e -> Caqti_error.show e
          | `Msg e -> e in
        Dream.error (fun log -> log "error in worker: %s" e);
        worker pool config
      end
    | RemoteFollow { id; remote; target; data } ->
      let res =
        Fun.flip Caqti_lwt.Pool.use pool @@ fun db ->
        Resolver.follow_local_user config id remote target data db |> sanitize in
      Lwt.bind res @@ fun res ->
      begin match res with
      | Ok () -> worker pool config
      | Error e ->
        let e = match e with
          | #Caqti_error.t as e -> Caqti_error.show e
          | `Msg e -> e in
        Dream.error (fun log -> log "error in worker: %s" e);
        worker pool config
      end
    | LocalFollow {local; username; domain} ->
      let res =
        Fun.flip Caqti_lwt.Pool.use pool @@ fun db ->
        Resolver.follow_remote_user config local ~username ~domain db |> sanitize in
      Lwt.bind res @@ fun res -> 
      begin match res with
      | Ok () -> worker pool config
      | Error e ->
        let e = match e with
          | #Caqti_error.t as e -> Caqti_error.show e
          | `Msg e -> e in
        Dream.error (fun log -> log "error in worker: %s" e);
        worker pool config
      end
